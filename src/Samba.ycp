/**
 * File:	modules/Samba.ycp
 * Package:	Configuration of samba-client
 * Summary:	Data for configuration of samba-client, input and output functions.
 * Authors:	Stanislav Visnovsky <visnov@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of samba-client.
 * Input and output routines. 
 */

{

module "Samba";
textdomain "samba-client";

import "Autologin";
import "FileUtils";
import "Mode";
import "Package";
import "PackageSystem";
import "Progress";
import "Report";
import "Service";
import "String";

import "SambaConfig";
import "SambaWinbind";
import "SambaNetJoin";
import "SambaNmbLookup";
import "SambaAD";


/**
 * Data was modified?
 */
global boolean modified = false;

/**
 * Are globals already configured (for AutoYaST)
 */
global boolean globals_configured = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Should be winbind enabled?
 */
global boolean winbind_enabled = false;


/**
 * Is name servcice cache enabled?
 */
global boolean nscd_enabled	= true;

/**
 * If FAM should be started
 */
global boolean start_fam	= true;

/**
 * if pam_mkhomedir is set in /etc/pam.d/commond-session
 */
global boolean mkhomedir	= false;

// if it mkhomedir was modified
boolean mkhomedir_modified	= false;

// if shares config (actually group owner) was modified
boolean shares_modified		= false;

/**
 * map with user name and password (used for autoinstallation only)
 */
global map<string,string> password_data	= $[];

// dir with user shares
global string shares_dir	= "/var/lib/samba/usershares";

global boolean remove_shares	= false;

global string shares_group	= "";

string shares_separator		= "\\";

/**
 * Data was modified?
 * @return true if modified
 */
global boolean GetModified() {
    y2debug("modified=%1",modified);
    return modified || mkhomedir_modified || shares_modified || SambaConfig::GetModified();
};

/**
 * Read the state of passwd and group cache in /etc/nscd
 */
define boolean ReadNscdState () {

    nscd_enabled	= Package::Installed ("nscd");

    list<string> enable_cache	=
	(list<string>) SCR::Read (.etc.nscd_conf.v.enable-cache);
    foreach (string sect, enable_cache, {
	list<string> l_cache = filter (
	    string part, splitstring (sect, " \t"), ``(part != ""));
	if (l_cache[0]:"" == "passwd" || l_cache[0]:"" == "group")
	{
	    nscd_enabled	= nscd_enabled && l_cache[1]:"" == "yes";
	}
    });
    return nscd_enabled;
}

/**
 * Read the state of mkhomedir in /etc/pam.d/common-session (bug #143519)
 */
global define boolean ReadMkHomeDir () {

    // FIXME this is very ugly, but since we currently don't have other way...
    mkhomedir	= false;
    string file_path	= "/etc/pam.d/common-session";
   if (!FileUtils::Exists (file_path))
    {
	return false;
    }
    string file = (string) SCR::Read (.target.string, file_path);
    foreach (string line, splitstring (file, "\n"), {
	if (regexpmatch (line, "[\t ]*#"))
	    return;
	if (issubstring (line,"pam_mkhomedir.so"))
	    mkhomedir = true;
    });
    return mkhomedir;
}

/**
 * Write the new value of pam_mkhomedir to /etc/pam.d/common-session
 * @param boolean new status
 */
global define boolean WriteMkHomeDir (boolean enabled) {

    if (!mkhomedir_modified)
	return true;

    string the_line	= "session optional\tpam_mkhomedir.so";
    string file_path	= "/etc/pam.d/common-session";
    if (!FileUtils::Exists (file_path))
    {
	SCR::Write (.target.string, file_path, the_line);
	return true;
    }
    string cont = (string) SCR::Read(.target.string, file_path);
    list<string> new_cont	= [];
    boolean done		= false;
    foreach (string line, splitstring (cont, "\n"), {
	if (regexpmatch (line, "[\t ]*#"))
	{
	    new_cont	= add (new_cont, line);
	    return;
	}
	else if (!done && enabled)
	{
	    new_cont	= add (new_cont, the_line);
	    done	= true;
	}
	if (enabled || !issubstring (line,"pam_mkhomedir.so"))
	    new_cont	= add (new_cont, line);
    });
    SCR::Execute (.target.bash, sformat ("/bin/cp %1 %1.YaST2save", file_path));
    return SCR::Write (.target.string, file_path, mergestring (new_cont, "\n"));
}

/**
 * Set the new value of mkhomedir
 */
global define boolean SetMkHomeDir (boolean new_value) {

    if (mkhomedir != new_value)
    {
	mkhomedir_modified	= true;
        mkhomedir = new_value;
    }
    return mkhomedir;

}

/**
 * get number of max shares from smb.conf; 0 mean shares are not enabled
 */
global define integer GetMaxShares () {

    return SambaConfig::GlobalGetInteger ("usershare max shares", 0);
}

/**
 * Read user shares settings
 */
global define boolean ReadSharesSetting () {

    shares_dir	= SambaConfig::GlobalGetStr ("usershare path", shares_dir);
    if (FileUtils::Exists (shares_dir))
    {
	map stat	= (map) SCR::Read (.target.stat, shares_dir);
	map out		= (map) SCR::Execute (.target.bash_output, sformat ("getent group | grep \":%1:\" | /usr/bin/cut -f 1 -d :", stat["gid"]:100));
	shares_group	= String::FirstChunk (out["stdout"]:"", "\n");
    }
    map out	= (map) SCR::Execute (.target.bash_output, "testparm -s --parameter-name 'winbind separator' 2>/dev/null");
    shares_separator	= String::FirstChunk (out["stdout"]:"\\", "\n");;
}

/**
 * set the new values for user shares
 */
global define boolean SetShares (integer max, string group)
{
    SambaConfig::GlobalSetStr ("usershare max shares", max > 0 ? max : nil);

    if (shares_group != group)
	shares_modified	= true;
    shares_group	= group;
    return true;
}

/**
 * Get the current status of winbind caching
 */
global define boolean GetWinbindCaching () {

    return SambaConfig::GlobalGetStr("pam_winbind:cached_login", "") == "yes" &&
	   SambaConfig::GlobalGetStr("winbind offline logon", "") == "yes";
}

/**
 * Set the new value for winbind caching (see bug #143927)
 */
global define boolean SetWinbindCaching (boolean enable) {

    SambaConfig::GlobalSetStr("pam_winbind:cached_login", enable ? "yes" : nil);
    SambaConfig::GlobalSetStr("winbind offline logon", enable ? "yes" : nil);
    return enable;
}

/**
 * Start/Stop and FAM service according to current settings
 * @param write_only do not start/stop services
 * @return success
 */
define boolean WriteFAM (boolean write_only) {

    if (start_fam)
    {
	if (!Package::InstalledAll (["fam","fam-server"]))
	    return false;

	Service::Enable ("fam");
	if (! write_only) Service::Start ("fam");
    }
    else
    {
	Service::Disable ("fam");
	if (!write_only) Service::Stop ("fam");
    }
    return true;
}

/**
 * create the shares directory with correct rights
 */
global boolean WriteShares () {

    if (!FileUtils::Exists (shares_dir))
    {
	SCR::Execute (.target.mkdir, shares_dir);
	if (shares_group == "") shares_group = "users";
	SCR::Execute (.target.bash, sformat ("/bin/chmod 1770 %1; /bin/chgrp %2 %1", shares_dir, shares_group));
    }
    else if (remove_shares)
    {
	SCR::Execute (.target.bash, sformat ("/bin/rm -f %1/*", shares_dir));
    }
    return true;
}

/**
 * Tell displaymanager (KDM/GDM) to use special windbind greeter
 * @param enable if  winbind is enabled
 * @param write_only do not run SuSEconfig script
 * @return success
 */
define boolean WriteDisplayManager (boolean enable, boolean write_only) {

    if (!FileUtils::Exists ("/etc/sysconfig/displaymanager"))
	return false;

    if (enable)
    {
	if (!Package::InstalledAny (["kdebase3-kdm", "gdm"]))
	    return false;
	if (SCR::Read (.sysconfig.displaymanager.DISPLAYMANAGER_AD_INTEGRATION) == "yes")
	    return true;
    }

    SCR::Write (.sysconfig.displaymanager.DISPLAYMANAGER_AD_INTEGRATION,
	enable ? "yes" : "no");
    SCR::Write (.sysconfig.displaymanager, nil);

    string dm = (string) SCR::Read (.sysconfig.displaymanager.DISPLAYMANAGER);

    if (!write_only && (dm == "kdm" || dm == "gdm"))
    {
	SCR::Execute (.target.bash,
	    "/sbin/SuSEconfig --module " + (dm == "gdm" ? dm : "kdm3"));
    }
    return true;
}

/**
 * Read all samba-client settings
 * @return true on success
 */
global boolean Read() {

    /* Samba-client read dialog caption */
    string caption = _("Initializing Samba Client Configuration");

    integer steps = 2;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // translators: progress stage 1/2
	    _("Read the global Samba settings"),
	    // translators: progress stage 2/2
	    _("Read the winbind status"),
	], [
	    // translators: progress step 1/2
	    _("Reading the global Samba settings..."),
	    // translators: progress step 2/2
	    _("Reading the winbind status..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // read global settings
    Progress::NextStage();
    SambaConfig::Read(false);

    // check installed packages
    if (!PackageSystem::CheckAndInstallPackagesInteractive(["samba-client"])) {
	y2warning("package samba-client not installed");
        return false;
    }

    // read winbind status
    Progress::NextStage();
    winbind_enabled = SambaWinbind::IsEnabled();

    // start nmbstatus in background
    if (!Mode::test()) {
	SambaNmbLookup::Start();
    }

//    ReadNscdState ();
    ReadMkHomeDir ();

    ReadSharesSetting ();

    Autologin::Read();

    // finished
    Progress::NextStage();
    globals_configured = true;
    modified = false;

    return true;
}

/**
 * Write all samba-client settings
 * @return true on success
 */
global boolean Write(boolean write_only) {
    boolean ret = true;

    /* Samba-client read dialog caption */
    string caption = _("Saving Samba Client Configuration");

    list<string> stages	= [
	    // translators: write progress stage
	    _("Write the settings"),
	    // translators: write progress stage
	    !winbind_enabled ? _("Disable Samba services") :
		// translators: write progress stage
		_("Enable Samba services")
    ];
    list<string> steps	= [
	    // translators: write progress step
	    _("Writing the settings..."),
	    // translators: write progress step
	    !winbind_enabled ? _("Disabling Samba services...")
		// translators: write progress step
		: _("Enabling Samba services..."),
	    // translators: write progress finished
	    _("Finished")
    ];

    if (SambaAD::ADS () != "" && winbind_enabled)
    {
	// write progress stage
	stages	= add (stages, _("Write Kerberos configuration"));
	// write progress step
	steps	= add (steps, _("Writing Kerberos configuration..."));
    }

    // We do not set help text here, because it was set outside
    Progress::New (caption, " ", size (stages), stages, steps, "");

    // write settings
    Progress::NextStage();

    // if nothing to write, quit (but show at least the progress bar :-)
    if (!GetModified()) return true;

    if (!SambaConfig::Write(write_only)) {
	// translators: error message, %1 is filename
	Report::Error (sformat(_("Cannot write settings to %1."), "/etc/samba/smb.conf") );
	ret = false;
    }

    // winbind
    Progress::NextStage();
    if (winbind_enabled) {
	if (!Package::Installed("samba-winbind") && !Mode::test()) {
		ret = false;
	}
	if (!SambaWinbind::AdjustService(true)) {
	    // translators: error message, do not change winbind
	    Report::Error( _("Cannot start winbind service."));
	    ret = false;
	}
	if (!write_only && !SambaWinbind::StartStopNow(true)) {
	    // translators: error message, do not change winbind
	    Report::Error(_("Cannot start winbind daemon."));
	    ret = false;
	}
    } else {
	if (!SambaWinbind::AdjustService(false)) {
	    // translators: error message, do not change winbind
	    Report::Error( _("Cannot stop winbind service."));
	    ret = false;
	}
	if (!write_only && !SambaWinbind::StartStopNow(false)) {
	    // translators: error message, do not change winbind
	    Report::Error(_("Cannot stop winbind daemon."));
	    ret = false;
	}
    }
// FIXME nscd_enabled = true, but check for write_only
    if (!SambaWinbind::AdjustNsswitch(winbind_enabled,nscd_enabled)) {
	// translators: error message, %1 is filename
	Report::Error(sformat(_("Cannot write settings to %1."), "/etc/nsswitch.conf"));
	ret = false;
    }
    if (!SambaWinbind::AdjustPam(winbind_enabled)) {
	// translators: error message, %1 is filename
	Report::Error(sformat(_("Cannot write settings to %1."), "/etc/security/pam_unix2.conf"));
	ret = false;
    }

    if (SambaAD::ADS () != "" && winbind_enabled)
	Progress::NextStage();

    if (!SambaAD::AdjustKerberos (winbind_enabled)) {
	// translators: error message, %1 is filename
	Report::Error(sformat(_("Cannot write settings to %1."), "/etc/krb5.conf"));
	ret = false;
    }

    WriteMkHomeDir (mkhomedir);

    // if autologin was modified, SuSEconfig script will be called there
    WriteDisplayManager (winbind_enabled, write_only || Autologin::modified);

    Autologin::Write(write_only);	// see dialog.ycp

    WriteFAM (write_only);

    // finished
    Progress::NextStage();
    modified = false;

    return ret;
}

/**
 * Get all samba-client settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    if (haskey(settings, "global")) {
	SambaConfig::GlobalSetStr("workgroup", settings["global","workgroup"]:"WORKGROUP");
	winbind_enabled = settings["global","winbind"]:false;
	globals_configured = true;
        modified = false;
    } else {
	globals_configured = false;
    }
    if (haskey(settings, "active_directory"))
    {
	SambaAD::SetADS	(settings["active_directory","kdc"]:"");
	if (!Mode::config ())
	{
	    SambaConfig::GlobalSetStr("workgroup",
	      SambaAD::GetWorkgroup(SambaConfig::GlobalGetStr("workgroup","")));
	    SambaAD::ReadRealm ();
	}
    }
    if (haskey(settings, "join") && Mode::autoinst ())
    {
	y2milestone ("join result: %1",
	    SambaNetJoin::Join (SambaConfig::GlobalGetStr("workgroup",""),
		"member",
		settings["join","user"]:"",
		settings["join","password"]:""
	    ));
    }

    return true;
}

/**
 * Dump the samba-client settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {

    if (!globals_configured) {
	return $[];
    }

    map globals = $[
	"workgroup": SambaConfig::GlobalGetStr("workgroup", ""),
	"winbind" : winbind_enabled,
    ];
    map ret	= $[ "global": globals ];
    if (SambaAD::ADS() != "")
    {
	ret["active_directory"]	= $[
	    "kdc" : SambaAD::ADS()
	];
    }
    // export user & password to "join" map
    map joinmap	= $[];
    foreach (string key, string val, password_data, {
	if (val != nil && val != "")
	    joinmap[key]	= val;
    });
    if (joinmap != $[])
	ret["join"]	= joinmap;
    modified = false;
    return ret;
}

/**
 * Create a textual summary and a list of unconfigured options
 * @return summary of the current configuration
 */
global string Summary() {
    import "Summary";
    
    string summary = "";
    string nc = Summary::NotConfigured();
    string workgroup = SambaConfig::GlobalGetStr("workgroup", "");
    
    // summary header
    summary = Summary::AddHeader(summary, _("Global Configuration"));
    
    if( globals_configured ) {
	// autoyast summary item: configured workgroup 
	summary = Summary::AddLine(summary, sformat(_("Workgroup or Domain: %1"), workgroup ) );
    } else {
	summary = Summary::AddLine(summary, nc );
    }
    
    return summary;
}

/**
 * Create shorter textual summary and a list of unconfigured options
 * @return summary of the current configuration
 */
global string ShortSummary() {
    import "Summary";

    string summary = "";
    string workgroup = SambaConfig::GlobalGetStr("workgroup", "");

    if (globals_configured) {
	// summary item: configured workgroup
	summary = sformat(_("<p><b>Workgroup or Domain</b>: %1</p>"), workgroup) +
	// summary item: authentication using winbind
	sformat(_("<p><b>Authentication with SMB</b>: %1</p>"),
	    // translators: winbind status in summary
	    winbind_enabled ? _("Yes")
	    // translators: winbind status in summary
		: _("No"));
    } else {
	summary = Summary::NotConfigured();
    }
    return summary;
}


/**
 * Set a host workgroup
 *
 * @param group	a new workgroup
 */
global void SetWorkgroup( string group ) {
    SambaConfig::GlobalSetStr("workgroup", group);
}

/**
 * Get a host workgroup
 *
 * @return string	a new workgroup
 */
global string GetWorkgroup() {
    return SambaConfig::GlobalGetStr("workgroup", "");
}

global string GetWorkgroupOrRealm() {
    string workgroup = SambaConfig::GlobalGetStr("workgroup", "");
    if (toupper (SambaConfig::GlobalGetStr("security","")) == "ADS")
    {
	return SambaConfig::GlobalGetStr("realm", workgroup);
    }
    return workgroup;
}


/**
 * Set a windind status
 *
 * @param group	a new winbind status
 */
global define void SetWinbind(boolean status) ``{
    if (status != winbind_enabled) {
	modified = true;
	winbind_enabled = status;
    }
    SambaAD::AdjustSambaConfig(status);
    SambaWinbind::AdjustSambaConfig(status);
}

/**
 * Get a winbind status
 *
 * @return booleand	a winbind status
 */
global define boolean GetWinbind() ``{
    return winbind_enabled;
}

/**
 * Return required packages for auto-installation
 * @return map of packages to be installed and to be removed
 */
global define map AutoPackages() ``{
    list to_install = ["samba-client", "samba-winbind"];
    if (SambaAD::ADS () != "")
	to_install = union (to_install, ["krb5", "krb5-client"]);
    return $["install": to_install, "remove": []];
}

/**
 * update the information if FAM should be started
 * @return current fam status
 */
global define boolean SetStartFAM (boolean fam) {

    if (fam != start_fam)
    {
	start_fam	= fam;
	modified	= true;
    }
    return start_fam;
}

/**
 * update the information if nscd should be enabled
 * @return current nscd status
 */
global define boolean SetNscdState (boolean nscd) {

    if (nscd != nscd_enabled)
    {
	nscd_enabled	= nscd;
	modified	= true;
    }
    return nscd_enabled;
}

/**
 * return the help text for shares
 */
global string SharesHelp () {

    return

    // membership dialog help (common part 3/4), %1 is separator (e.g. '\')
    sformat (_("<p><b>Allow Users to Share Their Directories</b> enables members of the group in <b>Permitted Group</b> to share directories they own with other users. For example, <tt>users</tt> for a local scope or <tt>DOMAIN%1Users</tt> for a domain scope.  The user also must make sure that the file system permissions allow access.</p>"), shares_separator) +

    // membership dialog help (common part 3/4)
    _("<p>With <b>Maximum Number of Shares</b>, limit the total amount of shares that may be created.</p>");
}


/* EOF */
}
