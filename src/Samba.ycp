/**
 * File:	modules/Samba.ycp
 * Package:	Configuration of samba-client
 * Summary:	Data for configuration of samba-client, input and output functions.
 * Authors:	Stanislav Visnovsky <visnov@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of samba-client.
 * Input and output routines.
 */

{

module "Samba";
textdomain "samba-client";

import "Progress";
import "Report";
import "Summary";
import "Runlevel";
import "Pam";

include "samba-client/routines.ycp";

global block AbortFunction = nil;

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 * Are globals already configured (for AutoYaST)
 */
global boolean globals_configured = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/** ================================ global data =============================*/

/**
 * name of a workgroup for the host
 */
global string workgroup = "WORKGROUP";

/**
 * security level for the host
 */
global string security = "user";

/**
 * netbios name of the host
 */
global string netbios_name = nil;

/**
 * password server setting from smb.conf
 */
global string password_server = nil;

/**
 * Should be winbind enabled?
 */
global boolean winbind = false;

/**
 * UIDs used by winbind
 */
global string winbind_uid = nil;

/**
 * GIDs used by winbind
 */
global string winbind_gid = nil;

/** ============================= end of global data ==========================*/

/**
 * Path to the nmbstatus binary
 */
string nmbstatus = "/usr/sbin/nmbstatus";

/** ============================= defaults ====================================*/

/** ============================= end of defaults =============================*/

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

/**
 * Read all samba-client settings
 * @return true on success
 */
global define boolean Read() ``{

    /* Samba-client read dialog caption */
    string caption = _("Initializing samba-client configuration");

    integer steps = 1;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    _("Read the global SAMBA settings"),
	], [
	    _("Reading the global SAMBA settings"),
	    _("Finished")
	],
	""
    );

    // read global settings
    Progress::NextStage();
    
    string value = "";
    
    value = SCR::Read( .etc.smb.value.global."workgroup" );
    if( value != nil ) workgroup = value;
    value = SCR::Read( .etc.smb.value.global."security" );
    if( value != nil ) security = value;
    value = SCR::Read( .etc.smb.value.global."password server" );
    if( value != nil ) password_server = value;
    value = SCR::Read( .etc.smb.value.global."netbios name" );
    if( value != nil ) workgroup = value;
    else {
	// ask hostname
	map res = SCR::Execute( .target.bash_output, "/bin/hostname" );
	if( res["exit"]:-1 != 0 ) netbios_name = "localhost";
	else netbios_name = deletechars( res["stdout"]:"localhost", "\n\t " );
	y2debug( "Netbios name: %1", netbios_name );
    }
    
    winbind_uid = SCR::Read( .etc.smb.value.global."winbind uid" );
    winbind_gid = SCR::Read( .etc.smb.value.global."winbind gid" );
    
    winbind = Runlevel::ServiceEnabled( "winbind" );
    
    globals_configured = true;
    
    if(Abort()) return false;
    ProgressNextStage(_("Finished"));

    modified = false;
    return true;
}

/**
 * Write all samba-client settings
 * @return true on success
 */
global define boolean Write() ``{

    /* Samba-client read dialog caption */
    string caption = _("Saving Samba client configuration");

    integer steps = 3;

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    // translators: write progress stage
	    _("Write the settings"),
	    // translators: write progress stage
	    !winbind ? _("Disable SAMBA services") : _("Enable SAMBA services")
	], [
	    // translators: write progress step
	    _("Writing the settings..."),
	    // translators: write progress step
	    !winbind ? _("Disabling SAMBA services") : _("Enabling SAMBA services"),
	    // translators: write progress step
	    _("Finished")
	],
	""
    );
    
    // if nothing to write, quit (but show at least the progress bar :-)
    if( ! modified ) return true;

    // write settings
    if(Abort()) return false;
    Progress::NextStage();
    
    WriteSettings();

    if( !SCR::Write( .etc.smb, nil ) ) Report::Error (sformat(_("Cannot write settings to %1!"), "/etc/samba/smb.conf") );

    if(Abort()) return false;
    Progress::NextStage ();

    // winbind    
    enableWinbind( winbind );
    
    if(Abort()) return false;
    ProgressNextStage(_("Finished"));

    if(Abort()) return false;
    return true;
}

/**
 * Write all samba-client settings
 * @return true on success
 */
global define boolean WriteSettings() ``{

    // write global settings
    SCR::Write( .etc.smb.value.global.workgroup, workgroup );
    SCR::Write( .etc.smb.value.global.security, security );
    if( size(password_server) > 0 )
	SCR::Write( .etc.smb.value.global."password server", password_server );
    
    // ensure "encrypt passwords = yes";
    SCR::Write( .etc.smb.value.global."encrypt passwords" , "yes" );
    
    WriteWinbind(winbind);
}

/**
 * Get all samba-client settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{

    if( size( settings ) == 0 ) return true;
    
    // read global settings
    workgroup = settings["global","workgroup"]:workgroup;

    winbind = settings["global","winbind"]: winbind;
    
    globals_configured = true;

    return true;
}

/**
 * Dump the samba-client settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{

    map globals = $[
	"workgroup": workgroup,
	"winbind" : winbind
    ];
    
    return $[ "global": globals ];
}

/**
 * Create a textual summary and a list of unconfigured options
 * @return summary of the current configuration
 */
global define string Summary() ``{
    
    string summary = "";
    string nc = Summary::NotConfigured ();
    
    // summary header
    summary = Summary::AddHeader(summary, _("Global configuration"));
    
    if( globals_configured ) {
	// summary item: an option is turned on
	summary = Summary::AddLine(summary, sformat(_("Workgroup/Domain: %1"), workgroup ) );
    } else {
	summary = Summary::AddLine(summary, nc );
    }
    
    return summary;
}

/**
 * Set a host workgroup
 *
 * @param workgroup	a new workgroup
 */
global define void setWorkgroup( string workgroup ) ``{
    if( Samba::workgroup != workgroup ) {
	Samba::workgroup = workgroup;
	modified = true;
    }
}

/**
 * Enable or disable winbind configuration.
 *
 * @param status a new status
 */
global define void setWinbind( boolean status ) ``{
    if( Samba::winbind != status ) {
	Samba::winbind = status;
	modified = true;
    }
}

/** 
 * Joins the host into a given domain. If user is provided, it will use
 * the user and password for joining. If the user is nil, joining will
 * be done anonymously.
 *
 * Attention: It will write the configuration for domain before settings the password
 *
 * @param domain	a name of a domain to be joined
 * @param user		username to be used for joining, or nil for anonymous
 * @param passwd	password for the user
 * @return string	an error message or nil if successful
 */
global define string joinDomain( string domain, string user, string passwd ) ``{
    if( user == "" ) user = nil;
    
    security = "domain";
    workgroup = domain;

    // write the settings to the disk
    WriteSettings();
    // FIXME:
    WriteSAMBackend();
    // FIXME:
    ReloadSettings();
    
    // set the actual password (-s means password on stdin)
    string cmd = "smbpasswd -s -j " + domain;
    
    if( user != nil ) {
	string passwddir = SCR::Read( .target.tmpdir );
	SCR::Write( .target.string, passwddir+"/domain" , passwd+"\n"+passwd+"\n" );
	cmd = cmd+" < "+passwddir+"/domain";
    }
    map result = SCR::Execute( .target.bash_output, cmd );
    
    y2debug( "smbpasswd -j result: %1", result );
    
        // check the exit code, return nil on success
    if( result["exit"]:1 == 0 ) return nil;
    
    // otherwise return stderr
    
    // translators: Error message is unknown error happened when joining a domain
    string res = result["stderr"]:_("Unable to join the domain.");
    
    return res == ""? _("Unable to join the domain.") : res;
}

/**
 * Check if this host is a member of a given domain. TODO: this does not work correctly now
 *
 * @param domain  a name of the domain to check
 * @return boolean  true if the host is a member, false if not, nil on error (not possible to find out)
 */
global define boolean isDomainMember( string domain ) ``{
    if( Runlevel::ServiceStatus( "winbind" ) == 0 ) {
	map res = SCR::Execute( .target.bash_output, "LANG=C wbinfo -t" );
	y2error( "wbinfo -t : %1", res );
	if( res["exit"]:-1 != 0 ) return nil;
	return res["stdout"]:"" == "Secret is good\n";
    }
    else 
    {
	string tmpsmbconf = SCR::Read( .target.tmpdir ) + "/smb.conf" ;
	SCR::Write( .target.string, tmpsmbconf, "[global]\nwinbind uid = 10000-20000
winbind gid = 10000-20000\nworkgroup = "+domain+"\nsecurity=domain\n" );
	SCR::Execute( .background.run_output, "/usr/sbin/winbindd -s "+tmpsmbconf );
	// sleep a bit
	sleep( 1000 );
	// do the test
	map res = SCR::Execute( .target.bash_output, "LANG=C wbinfo -t" );
	y2error( "wbinfo -t : %1", res );
	// quit winbind
	SCR::Execute( .background.kill );
	if( res["exit"]:-1 != 0 ) return nil;
	return res["stdout"]:"" == "Secret is good\n";
    }
}

/**
 * Check if a given workgroup is a domain or not. Tests presence of PDC or BDC in the workgroup.
 * 
 * @param workgroup	the name of a workgroup to be tested
 * @return boolean	true if the workgroup is a domain
 */
global define boolean isDomain( string workgroup ) ``{
    integer res = SCR::Execute( .target.bash, nmbstatus + " --quiet --pdc --workgroup " + workgroup );
    
    // if there is PDC, return success
    if( res == 0 ) return true;
    
    // if PDC not found, try BDC
    if( res == 1 ) {
	res = SCR::Execute( .target.bash, nmbstatus + " --quiet --bdc --workgroup " + workgroup );
	return res == 0 ;
    }
    
    // a different error happened
    return false;
}

/** 
 * Enable/disable and start/stop winbindd services.
 *
 * @param on the status of the winbind to be configured (true=enabled, false=disabled)
 * @return boolean true on success
*/
global define boolean enableWinbind( boolean on ) ``{
    // enable winbind service
    if( ! Runlevel::ServiceAdjust( "winbind", on ? "enable": "disable" ) )
    {
	Report::Error( on ? _("Cannot start winbindd daemon."): _("Cannot stop winbindd daemon.") );
	return false;
    }
    
    if( write_only ) return true;
    
    if( on ) {
	// start the server
	if( Runlevel::ServiceStatus( "winbind" ) != 0 ) {
	    // the service does not run
	    if( Runlevel::RunInitScript( "winbind", "start" ) != 0 ) {
		Report::Error( _("Cannot start 'winbind' service.") );
	    }
	}
    } else {
	// the service is running
	if( Runlevel::ServiceStatus( "winbind" ) == 0 ) {
	    if( Runlevel::RunInitScript( "winbind", "stop" ) != 0 ) {
		Report::Error( _("Cannot stop 'winbind' service.") );
	    }
	}
    }

    return true;
}

/** 
 * Write winbindd configuration. It modifies smb.conf and nsswitch.conf.
 *
 * @param on the status of the winbind to be configured (true=enabled, false=disabled)
*/
global define void WriteWinbind( boolean on ) ``{
    if( on ) {
	// if turning on and there is no values set, use default
	if( winbind_uid == nil ) winbind_uid = "10000-20000";
	if( winbind_gid == nil ) winbind_gid = "10000-20000";
    }
    
    SCR::Write( .etc.smb.global."winbind uid", winbind_uid );
    SCR::Write( .etc.smb.global."winbind gid", winbind_gid );
    
    // change nsswitch
    list nsswitch_list = splitstring
            (SCR::Read(.etc.nsswitch_conf.passwd)," ");
	    
    if( on ) {
	if( !contains( nsswitch_list, "winbind" ) ) 
	    nsswitch_list = add( nsswitch_list, "winbind" );
    }
    else
    {
	if( contains( nsswitch_list, "winbind" ) )
	    nsswitch_list = filter( string part, nsswitch_list, ``(part != "winbind" ) );
    }
    
    SCR::Write(.etc.nsswitch_conf.passwd, mergestring( nsswitch_list, " " ) );
    
    nsswitch_list = splitstring
            (SCR::Read(.etc.nsswitch_conf.group), " ");

    if( on ) {
	if( !contains( nsswitch_list, "winbind" ) )
	    nsswitch_list = add( nsswitch_list, "winbind" );
    }
    else
    {
	if( contains( nsswitch_list, "winbind" ) )
	    nsswitch_list = filter( string part, nsswitch_list, ``(part != "winbind" ) );
    }

    SCR::Write(.etc.nsswitch_conf.group, mergestring( nsswitch_list, " " ) );

    if( !SCR::Write(.etc.nsswitch_conf, nil ) )
	Report::Error (sformat(_("Cannot write settings to %1!"), "/etc/nsswitch.conf") );
    
    // change pam.d/login
    
    Pam::UpdatePAMLoginFor(on ? [ $["service":"winbind", "control": "sufficient" ] ] : [], ["login"] );

    // TODO: add: account sufficient /lib/security/pam_winbind.so
}

/**
 * Return a list of workgroups already existing in the lan.
 * @return list  of found workgroups/domains
 */
global define list availableWorkgroups() ``{
    map ret = SCR::Execute( .target.bash_output, nmbstatus );
    if( ret["exit"]:-1 != 0 ) {
	Report::Error( _("Cannot get a list of already existing workgroups.") );
	return nil;
    }
    list lines = splitstring( ret["stdout"]:"", "\n" );
    
    list result = [];
    
    foreach( string line, lines, ``{
	list cols = splitstring( line, "\t" );
	if( cols != [] && cols[0]:"" == "WORKGROUP" ) {
	    result = add( result, cols[1]:_("unknown") );
	}
    });
    
    return result;
}
				    
/* EOF */
}
