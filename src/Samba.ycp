/**
 * File:	modules/Samba.ycp
 * Package:	Configuration of samba-client
 * Summary:	Data for configuration of samba-client, input and output functions.
 * Authors:	Stanislav Visnovsky <visnov@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of samba-client.
 * Input and output routines.
 */

{

module "Samba";
textdomain "samba-client";

import "PamSettings";
import "Progress";
import "Report";
import "Summary";
import "Runlevel";

include "samba-client/routines.ycp";




/**
 * list of required packages
 */
global list required_packages = ["samba-client"];

global block AbortFunction = nil;

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 * Are globals already configured (for AutoYaST)
 */
global boolean globals_configured = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/** ================================ global data =============================*/

/**
 * name of a workgroup for the host
 */
global string workgroup = "WORKGROUP";

/**
 * security level for the host
 */
global string security = "user";

/**
 * netbios name of the host
 */
global string netbios_name = nil;

/**
 * password server setting from smb.conf
 */
global string password_server = nil;

/**
 * Should be winbind enabled?
 */
global boolean winbind = false;

/**
 * UIDs used by winbind
 */
global string winbind_uid = nil;

/**
 * GIDs used by winbind
 */
global string winbind_gid = nil;

/**
 * is nmbstatus still running?
 */
global boolean nmbstatus_running = false;

/**
 * nmbstatus output
 */
global map nmbstatus_output = $[];

/** ============================= end of global data ==========================*/

/**
 * Path to the nmbstatus binary
 */
string nmbstatus = "/usr/bin/nmbstatus";

/** ============================= defaults ====================================*/

/** ============================= end of defaults =============================*/

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

/**
 * Read all samba-client settings
 * @return true on success
 */
global define boolean Read() ``{

    /* Samba-client read dialog caption */
    string caption = _("Initializing Samba Client Configuration");

    integer steps = 1;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // translators: progress stage 1/1
	    _("Read the global SAMBA settings"),
	], [
	    // translators: progress step 1/1
	    _("Reading the global SAMBA settings..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // read global settings
    Progress::NextStage();
    
    string value = "";
    
    value = SCR::Read( .etc.smb.value.global."workgroup" );
    if( value != nil ) workgroup = value;
    value = SCR::Read( .etc.smb.value.global."security" );
    if( value != nil ) security = value;
    value = SCR::Read( .etc.smb.value.global."password server" );
    if( value != nil ) password_server = value;
    value = SCR::Read( .etc.smb.value.global."netbios name" );
    if( value != nil ) workgroup = value;
    else {
	// ask hostname
	map res = SCR::Execute( .target.bash_output, "/bin/hostname" );
	if( res["exit"]:-1 != 0 ) netbios_name = "localhost";
	else netbios_name = deletechars( res["stdout"]:"localhost", "\n\t " );
	y2debug( "Netbios name: %1", netbios_name );
    }
    
    winbind_uid = SCR::Read( .etc.smb.value.global."winbind uid" );
    winbind_gid = SCR::Read( .etc.smb.value.global."winbind gid" );
    
    winbind = Runlevel::ServiceEnabled( "winbind" );
    
    globals_configured = true;
    
    if(Abort()) return false;
    // translators: progress finished
    ProgressNextStage(_("Finished"));
    
    // start nmbstatus
    nmbstatus_running = SCR::Execute(.background.run_output, nmbstatus);
    if( ! nmbstatus_running ) {
	y2error( "Cannot start nmbstatus" );
    }

    modified = false;
    return true;
}

/**
 * Write all samba-client settings
 * @return true on success
 */
global define boolean Write() ``{

    /* Samba-client read dialog caption */
    string caption = _("Saving Samba Client Configuration");

    integer steps = 3;

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    // translators: write progress stage
	    _("Write the settings"),
	    // translators: write progress stage
	    !winbind ? _("Disable SAMBA services") : 
		// translators: write progress stage
		_("Enable SAMBA services")
	], [
	    // translators: write progress step
	    _("Writing the settings..."),
	    // translators: write progress step
	    !winbind ? _("Disabling SAMBA services...") 
		// translators: write progress step
		: _("Enabling SAMBA services..."),
	    // translators: write progress finished
	    _("Finished")
	],
	""
    );
    
    // if nothing to write, quit (but show at least the progress bar :-)
    if( ! modified ) return true;

    // write settings
    if(Abort()) return false;
    Progress::NextStage();
    
    WriteSettings();

    if( !SCR::Write( .etc.smb, nil ) ) {
	// translators: error message
	Report::Error (sformat(_("Cannot write settings to %1."), "/etc/samba/smb.conf") );
    }

    if(Abort()) return false;
    Progress::NextStage ();

    // winbind    
    enableWinbind( winbind );
    
    if(Abort()) return false;
    ProgressNextStage(_("Finished"));

    if(Abort()) return false;
    return true;
}

/**
 * Write all samba-client settings
 * @return true on success
 */
global define boolean WriteSettings() ``{

    // write global settings
    SCR::Write( .etc.smb.value.global.workgroup, workgroup );
    SCR::Write( .etc.smb.value.global.security, security );
    if( size(password_server) > 0 )
	SCR::Write( .etc.smb.value.global."password server", password_server );
    
    // ensure "encrypt passwords = yes";
    SCR::Write( .etc.smb.value.global."encrypt passwords" , "yes" );
    
    WriteWinbind(winbind);
}

/**
 * Get all samba-client settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{

    if (settings == $[] ) {
		workgroup = "WORKGROUP";
		winbind = false;
		return true;
	}
    // read global settings
    workgroup = settings["global","workgroup"]:"WORKGROUP";

    winbind = settings["global","winbind"]:false;
    
    globals_configured = true;

    return true;
}

/**
 * Dump the samba-client settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{

    map globals = $[
	"workgroup": workgroup,
	"winbind" : winbind
    ];
    
    modified = false;
    
    return $[ "global": globals ];
}

/**
 * Create a textual summary and a list of unconfigured options
 * @return summary of the current configuration
 */
global define string Summary() ``{
    
    string summary = "";
    string nc = Summary::NotConfigured ();
    
    // summary header
    summary = Summary::AddHeader(summary, _("Global Configuration"));
    
    if( globals_configured ) {
	// autoyast summary item: configured workgroup 
	summary = Summary::AddLine(summary, sformat(_("Workgroup or Domain: %1"), workgroup ) );
    } else {
	summary = Summary::AddLine(summary, nc );
    }
    
    return summary;
}

/**
 * Create shorter textual summary and a list of unconfigured options
 * @return summary of the current configuration
 */
global define string ShortSummary() ``{

    string summary = "";

    if( globals_configured ) {
	// summary item: configured workgroup
	summary = sformat(_("<b>Workgroup or Domain</b>: %1<br>"), workgroup) +
	// summary item: authentication using winbind
	sformat(_("<b>Authentication with SMB</b>: %1"),
	    // translators: winbind status in summary
	    winbind ? _("Yes")
	    // translators: winbind status in summary
		: _("No"));
    } else {
	summary = Summary::NotConfigured ();
    }
    return summary;
}


/**
 * Set a host workgroup
 *
 * @param group	a new workgroup
 */
global define void setWorkgroup( string group ) ``{
    if( workgroup != group ) {
	workgroup = group;
	modified = true;
    }
}

/**
 * Enable or disable winbind configuration.
 *
 * @param status a new status
 */
global define void setWinbind( boolean status ) ``{
    if( winbind != status ) {
	winbind = status;
	modified = true;
    }
}

/** 
 * Joins the host into a given domain. If user is provided, it will use
 * the user and password for joining. If the user is nil, joining will
 * be done anonymously.
 *
 * Attention: It will write the configuration for domain before settings the password
 *
 * @param domain	a name of a domain to be joined
 * @param user		username to be used for joining, or nil for anonymous
 * @param passwd	password for the user
 * @return string	an error message or nil if successful
 */
global define string joinDomain( string domain, string user, string passwd ) ``{
    if( user == "" ) user = nil;
    
    security = "domain";
    workgroup = domain;

    // write the settings to the disk
    WriteSettings();
    
    // set the actual password (-s means password on stdin)
    string cmd = "smbpasswd -j " + domain;
    
    if( user != nil ) {
	cmd = cmd + " -U " + user + "%" + passwd;
    }
    
    map result = SCR::Execute( .target.bash_output, cmd );
    
    y2debug( "smbpasswd -j result: %1", result );
    
        // check the exit code, return nil on success
    if( result["exit"]:1 == 0 ) return nil;
    
    // otherwise return stderr
    
    // translators: Error message is unknown error happened when joining a domain
    string res = result["stderr"]:_("Unable to join the domain.");
    
    return res == ""? _("Unable to join the domain.") : res;
}

/**
 * Check if this host is a member of a given domain. TODO: this does not work correctly now
 *
 * @param domain  a name of the domain to check
 * @return boolean  true if the host is a member, false if not, nil on error (not possible to find out)
 */
global define boolean isDomainMember( string domain ) ``{
    
    if( Runlevel::ServiceStatus( "winbind" ) == 0 && SCR::Read( .etc.smb.value.global.workgroup ) == domain ) {
	map res = SCR::Execute( .target.bash_output, "LANG=C wbinfo -t" );
	y2error( "wbinfo -t : %1", res );
	if( res["exit"]:-1 != 0 ) return nil;
	return res["stdout"]:"" == "Secret is good\n";
    }
    else 
    {
	// finish nmbstatus run, since background agent supports only a single process
	CheckNmbstatus();
	
	// if winbindd already runs, but for different domain, stop it
	boolean winbindd_ran = Runlevel::ServiceStatus( "winbind" ) == 0;
	if( winbindd_ran ) Runlevel::RunInitScript( "winbind", "stop" );
	
	string tmpsmbconf = SCR::Read( .target.tmpdir ) + "/smb.conf" ;
	SCR::Write( .target.string, tmpsmbconf, "[global]\nwinbind uid = 10000-20000
winbind gid = 10000-20000\nworkgroup = "+domain+"\nsecurity=domain\n" );
	SCR::Execute( .background.run_output, "/usr/sbin/winbindd -s "+tmpsmbconf );
	// sleep a bit
	sleep( 1000 );
	// do the test
	map res = SCR::Execute( .target.bash_output, "LANG=C wbinfo -t" );
	y2debug( "wbinfo -t : %1", res );
	// quit winbind
	Runlevel::RunInitScript( "winbind", "stop" );
	y2debug( "Killing winbind: %1", SCR::Execute( .background.kill ) );
	
	// if winbindd ran before our tests, start it again
	if( winbindd_ran ) Runlevel::RunInitScript( "winbind", "restart" );
	
	if( res["exit"]:-1 != 0 ) return nil;
	return res["stdout"]:"" == "Secret is good\n";
    }
}

/**
 * Ensure that nmbstatus already finished. Then parse its output into nmbstatus_output
 */
global define void CheckNmbstatus() ``{
    if( nmbstatus_running ) {

	// better count slept time
	integer wait = 1200;
	
	while( wait>0 && SCR::Read( .background.isrunning ) ) {
	    sleep( 100 );
	    wait = wait -1;
	}
	
	if( SCR::Read( .background.isrunning ) ) {
	    y2error( "Something went wrong, nmbstatus didn't finish in more that 2 minutes" );

	    // better kill it
	    SCR::Execute( .background.kill );
	    nmbstatus_running = false;
	    nmbstatus_output = $[];
	}
	
	// nmbstatus already finished, parse the output
	list output = SCR::Read( .background.newout );
	
	y2debug( "nmbstatus result: %1", output );
	
	nmbstatus_running = false;
	nmbstatus_output = $[];
	
	string current_group = "";
	foreach( string line, output, ``{
	    list parts = splitstring( line, "\t" );

	    y2debug( "line parts: %1", parts );
	    
	    if( parts[0]:nil == "WORKGROUP" ) {
		current_group = parts[1]:"error";
		nmbstatus_output[current_group] = $[];
	    }
	    else if( parts[0]:nil != nil ) {
		nmbstatus_output[current_group, parts[0]:"error" ] = parts[1]:"error";
	    } // skip empty lines
	});
	
    }
}

/**
 * Check if a given workgroup is a domain or not. Tests presence of PDC or BDC in the workgroup.
 * 
 * @param workgroup	the name of a workgroup to be tested
 * @return boolean	true if the workgroup is a domain
 */
global define boolean isDomain( string workgroup ) ``{
    
    // ensure the data are up-to-date
    CheckNmbstatus();
    
    // if there is PDC, return success
    if( nmbstatus_output[ workgroup, "PDC" ]:nil != nil ) return true;
    
    // if PDC not found, try BDC
    if( nmbstatus_output[ workgroup, "BDC" ]:nil != nil ) return true;

    // a different error happened
    return false;
}

/** 
 * Enable/disable and start/stop winbindd services.
 *
 * @param on the status of the winbind to be configured (true=enabled, false=disabled)
 * @return boolean true on success
*/
global define boolean enableWinbind( boolean on ) ``{
    // enable winbind service
    if( ! Runlevel::ServiceAdjust( "winbind", on ? "enable": "disable" ) )
    {
	// translators: error message
	Report::Error( on ? _("Cannot start winbind daemon.")
	    // translators: error message
	    : _("Cannot stop winbind daemon.") );
	return false;
    }
    
    winbind = on;
    
    modified = true;
    
    if( write_only ) return true;
    
    if( on ) {
	// start the server
	if( Runlevel::ServiceStatus( "winbind" ) != 0 ) {
	    // the service does not run
	    if( Runlevel::RunInitScript( "winbind", "start" ) != 0 ) {
		// translators: error message
		Report::Error( _("Cannot start 'winbind' service.") );
	    }
	}
	
	// restart nscd daemon
	if( Runlevel::ServiceStatus( "nscd" ) == 0 ) {
	    Runlevel::RunInitScript( "nscd", "restart" );
	}
    } else {
	// the service is running
	if( Runlevel::ServiceStatus( "winbind" ) == 0 ) {
	    if( Runlevel::RunInitScript( "winbind", "stop" ) != 0 ) {
		// translators: error message
		Report::Error( _("Cannot stop 'winbind' service.") );
	    }
	}
    }

    return true;
}

/** 
 * Write winbindd configuration. It modifies smb.conf and nsswitch.conf.
 *
 * @param on the status of the winbind to be configured (true=enabled, false=disabled)
*/
global define void WriteWinbind( boolean on ) ``{
    if( on ) {
	// if turning on and there is no values set, use default
	if( winbind_uid == nil ) 
	    SCR::Write( .etc.smb.value.global."winbind uid", "10000-20000" );
	else
	    SCR::Write( .etc.smb.value.global."winbind uid", winbind_uid );
	if( winbind_gid == nil ) 
	    SCR::Write( .etc.smb.value.global."winbind gid", "10000-20000" );
	else
	    SCR::Write( .etc.smb.value.global."winbind gid", winbind_gid );
    }
    
    if( on ) {
	SCR::Write( .etc.smb.value.global.security, "domain" );
    }
    
    // change nsswitch
    list nsswitch_list = splitstring
            (SCR::Read(.etc.nsswitch_conf.passwd)," ");
	    
    if( on ) {
	if( !contains( nsswitch_list, "winbind" ) ) 
	    nsswitch_list = add( nsswitch_list, "winbind" );
    }
    else
    {
	if( contains( nsswitch_list, "winbind" ) )
	    nsswitch_list = filter( string part, nsswitch_list, ``(part != "winbind" ) );
    }
    
    SCR::Write(.etc.nsswitch_conf.passwd, mergestring( nsswitch_list, " " ) );
    
    nsswitch_list = splitstring
            (SCR::Read(.etc.nsswitch_conf.group), " ");

    if( on ) {
	if( !contains( nsswitch_list, "winbind" ) )
	    nsswitch_list = add( nsswitch_list, "winbind" );
    }
    else
    {
	if( contains( nsswitch_list, "winbind" ) )
	    nsswitch_list = filter( string part, nsswitch_list, ``(part != "winbind" ) );
    }

    SCR::Write(.etc.nsswitch_conf.group, mergestring( nsswitch_list, " " ) );

    if( !SCR::Write(.etc.nsswitch_conf, nil ) )
	// translators: error message
	Report::Error (sformat(_("Cannot write settings to %1."), "/etc/nsswitch.conf") );
    
    // change Pam configuration
    
    // auth
    list call_module = filter( string value, PamSettings::GetValues( "pam_unix2", "auth" ), ``(
      regexpmatch( value, "^call_modules=" )));
      
    y2debug( "Callmodule is %1", call_module );
      
    if( call_module == [] ) {
	if( on ) {
	    // add the option
	    PamSettings::AddValue( "pam_unix2", "auth", "call_modules=winbind" );
	}
	// do nothing for off
    } else {
	// find out list of called modules
	list mods = splitstring( regexpsub( call_module[0]:"", "^call_modules=(.*)", "\\1" ), "," );
	
	if( on ) {
	    // check, if present and add it if necessary
	    mods = union( mods, [ "winbind" ] );
	}
	else
	{
	    // if present, remove it
	    mods = filter( string mod, mods, ``( mod != "winbind" ) );
	}
	
	// change the current value
	PamSettings::RemoveValue( "pam_unix2", "auth", call_module[0]:"" );
	if( size(mods) > 0 ) {
	    PamSettings::AddValue( "pam_unix2", "auth", "call_modules="+mergestring( mods, "," ) );
	}
    }
    
    // account (the same as auth, but modules could be configured differently)
    call_module = filter( string value, PamSettings::GetValues( "pam_unix2", "account" ), ``(
      regexpmatch( value, "^call_modules=" )));
      
    if( call_module == [] ) {
	if( on ) {
	    // add the option
	    PamSettings::AddValue( "pam_unix2", "account", "call_modules=winbind" );
	}
	// do nothing for off
    } else {
	// find out list of called modules
	list mods = splitstring( regexpsub( call_module[0]:"", "^call_modules=(.*)", "\\1" ), "," );
	
	if( on ) {
	    // check, if present and add it if necessary
	    mods = union( mods, [ "winbind" ] );
	}
	else
	{
	    // if present, remove it
	    mods = filter( string mod, mods, ``( mod != "winbind" ) );
	}
	
	// change the current value
	PamSettings::RemoveValue( "pam_unix2", "account", call_module[0]:"" );
	if( size(mods) > 0 ) {
	    PamSettings::AddValue( "pam_unix2", "account", "call_modules="+mergestring( mods, "," ) );
	}
    }    
}

/**
 * Return a list of workgroups already existing in the lan.
 * @return list  of found workgroups/domains
 */
global define list availableWorkgroups() ``{
    
    CheckNmbstatus();

    // TODO: inform user about problems
    
    return maplist( string group, any data, nmbstatus_output, ``( group ) );
}


/**
 * Return required packages for auto-installation
 * @return map of packages to be installed and to be removed
 */
global define map AutoPackages() ``{
	return ($["install": required_packages, "remove": []]);

}



/* EOF */
}
